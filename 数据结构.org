* 数据结构
** 概论
   * 逻辑结构：
       线性结构：数组，队列，栈...
       非线性结构：树，图
   * 存储结构：顺序存储，链式存储
   * 数据间关系->属
     基本操作->方法
   * 算法与算法分析
     特性：输入，输出，确定性，有穷性，可行性
     评价标准：正确性，可读性(模块化结构，名称有意义，加注释，不用Goto语句)，健壮性(对非法输入进行判断处理)
     时间复杂性，空间复杂性
   * 算法分析：
       时间复杂度量，空间复杂度量
       
** 线性表 
   * 逻辑结构：具有相同类型的n个数据元素组成的有限序列
   * 存储结构：顺序结构(数组)，链式结构(指针)
   * /作业：将两个有序线性表进行合并 要求:(1)用顺序表实现 (2)用链表实现 (3)用菜单选择/
   * 链表：
     * 查找倒数k个元素：两个指针前后扫描
     * 循环链表，双向循环链表
   * 顺序表和链表的比较：
     * 顺序表：优点，随机存取；缺点：插入删除需要移动元素
     * 链表：优点，插入删除不需要移动元素；缺点：不能随机存

** 栈和队列
   * 栈：插入删除固定在某一端(FILO); 队列：插入一端，删除在另一端(FIFO)
   * 栈原理：栈空top=-1, 进栈top+1, 出栈top-1, 栈空不能pop, 栈满不能push
   * 两栈共享空间：栈底在两头，左边push：top++, 右边push：top--，两边相反
   * 链表实现，表头作为栈顶，头插方便,push没有上限，直至内存耗尽
   * 递归：递归的实现需要用栈,自己调用自己,递归必须有条件限制(求阶乘，汉诺塔)
     *编写递归算法的思路:*
     * 将大问题分解为若干个小问题，并且小问题的与大问题的解决算法一样
     * 寻找递归的终止条件和结果，当小问题小到什么时候，可以知道结果
     *编写求解汉诺塔问题的算法:*
     * 将n-1个盘中搬到B,将最后一个盘子搬到C,将n-1个盘子搬到C，完成
   * 栈的应用：表达式求值
     - 转化为后缀表达式
       * 不需要栈
     - 运算符优先法
       * 两个栈：运算符栈，操作数栈
       * 每当运算符要进栈时，当前运算符与栈顶运算符比较，小于等于pop，大于push
       * 出栈运算结果再进栈
       * pop时，下面的操作数 exp 上面操作数
   * 表达式
     * 前缀，中缀，后缀
     * 后缀：操作数位置不变，调整的是运算符位置
   * /第三章上机实验：输入一个算术表达式，利用算符优先法求值。例：86.35+(78.4-60.5)*1000/
--------------------------
   * 顺序队列:(循环队列)
     * 进队:(rear+1)%MaxSize , 出队:(front+1)%MaxSize
     * front指向头节点前面，rear指向实际的尾节点
     * 队空时front=rear,队空时不能出队，队满时不能进队
     * 如何解决判断队空还是队满的情况？
       * 浪费一个空间，队满时rear=MaxSize-1，即：(rear+1)%MAxsize==front
       * 设置一个布尔变量flag
       * 记录元素个数,num放在class中
   * 链式队列：
     * 出队：删除头节点，出队：插入尾节点
     * 只有一个节点时，出队需要将rear保护起来，让front=rear
       
** 字符串
   * 串的连接
   * 串的比较
   * 串的复制
   * 倒转一句英文
   * 删除特定字符
   * 模式匹配
     * BF算法:时间复杂性->最好O(n+m),最坏O(n*m)
     * KMP算法:关键是next()数组
       * next数组至于模式串有关
       * next数组算法: j=0时匹配失败,next[j]=-1; 否则 next[j]=前缀字串和后缀字串相等时的最大长度
       * 思想:模式串回溯next[j]的长度
   * 上机实验：串的查找替换，输入3个串s,t,p,将s串中所有的t串替换成p串。
     
** 数组和特殊矩阵
   * 数组特点：
     * 线性表本质：相同类型的线性序列
     * 存储结构：行优先顺序，列优先顺序
     * 随机存取，地址可计算
   * 特殊矩阵
     * 对称矩阵
     * 三角矩阵
     * 对角矩阵
     * 稀疏矩阵：只存放非零元素，三元组表法，十字链表法

** 广义表 
   * 概念：
     * 线性表是特殊的广义表，广义表是非特殊结构，数据类型可以不同
     * 长度，深度，表头，表尾:除表头外剩余部分
** 树与二叉树
*** 概念
    * 顺序存储：利用完全二叉树的性质：左孩子的下表是父节点的二倍(从1开始)
    * 链式存储：一个data，两个指针
    * 遍历顺序:
      * 先序遍历：根左右,根节点第一个访问
      * 中序遍历：左根右
      * 后序遍历：左右根，根节点最后一个访问
      * 层次遍历：一层层遍历,使用队列实现
    * 遍历的序列与二叉树的关系:
      * 一个遍历序列不能确定唯一的二叉树
      * 先序和中序两个序列可以确定唯一的二叉树(中序可以分左右)
      * 后序和中序两个序列也可以确定唯一的二叉树
    * 遍历算法:
      * 先序,中序,后序：递归
      * 层次遍历：队列实现，保存节点的指针

*** 线索二叉树(线索：指向前驱或后继的指针)
    * 原因：一般的二叉树存在n+1个空指针(n为节点数)，把空指针作为指向前驱或者后继的指针。指针有两个功能：指向孩子节点或者前驱后继节点，使用标记flag区分(广义表思想)。flag=0,指向子节点，flag=1，指向前驱或后继节点。
    * 找后继节点：if flag=1,取线索， if flag=0,有右孩子，且右孩子没有左孩子，则后继为该右孩子；如果右孩子有左孩子，则一直往下找到最终的左孩子。(同理找前驱节点)
    * 遍历:利用求后继节点的算法。第一个节点：从根节点一直往下找最后一个左孩子
    * 找父节点：左孩子身份出现往右走，右孩子身份出现往左走
*** 树 
    * 存储结构
      * 多叉链表表示法：选择节点数最多的个数来确定每个节点的指针数。空间利用率低。
      * 孩子链表表示法：
      * 双亲表示法：
      * 孩子兄弟表示法：左指针指向真正的左孩子，右指针指向兄弟节点
    * 求树的高度
    * 树中所有节点的度
    * 遍历：先根(与二叉树的先序遍历一致)，后根(与二叉树中序遍历一致)
*** Huffman树与Huffman编码
    * 概念：
      * 等长编码与不等长编码
      * 编码不能有二义性，一个编码不能是另一个编码的前缀
      * Huffman编码是不等长编码
      * 出现频率高的编码bit少，频率低的编码bit多，压缩优化
      * Huffman树 = 最优二叉树：带权路径长度最小权值 = 编码的最终长度
      * Huffman树没有单独的节点，节点总数为2n-1
      * 算法：把所有的节点都作为根节点，每次都选两个最小的根节点生成新的根节点
      * 实现：用结构体数组

** 图
*** 概念
    * 顶点集和边集
    * 邻节点
    * 无向完全图边数：n(n-1)/2
    * 有向完全图边数：n(n-1)
    * 带权图(网)，无权图
    * 顶点的度：与顶点相连的边的条数
    * 入度，出度
    * 路径，路径长度
    * 简单路径：不形成环
    * 回路：环
    * 连通图：从一个节点可以到达所有节点
    * 连通分量：不连通图中连通的部分
    * 强连通图：有向连通图
    * 强连通分量：有向图的连通分量
    * 生成树：
*** 存储结构
    * 邻接矩阵表示法
      * 无向图：矩阵对称, 每一行的和为该顶点的度数
      * 有向图：每个顶点的出度为1, 每一行的和为入度，每一列的和为出度
      * 网：有边用权值表示，没有边表示为0或无穷大
      * 通过输入实现顶点与边的关系
    * 邻接表表示法
      * 类似树的孩子链表表示法，孩子为图中的邻接点
      * 带权邻接表：在每个节点中增加一个权值域
