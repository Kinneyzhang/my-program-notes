* 数据结构
** 概论
   * 逻辑结构：
       线性结构：数组，队列，栈...
       非线性结构：树，图
   * 存储结构：顺序存储，链式存储
   * 数据间关系->属
     基本操作->方法
   * 算法与算法分析
     特性：输入，输出，确定性，有穷性，可行性
     评价标准：正确性，可读性(模块化结构，名称有意义，加注释，不用Goto语句)，健壮性(对非法输入进行判断处理)
     时间复杂性，空间复杂性
   * 算法分析：
       时间复杂度量，空间复杂度量

** 线性表
   * 逻辑结构：具有相同类型的n个数据元素组成的有限序列
   * 存储结构：顺序结构(数组)，链式结构(指针)
   * /作业：将两个有序线性表进行合并 要求:(1)用顺序表实现 (2)用链表实现 (3)用菜单选择/
   * 链表：
     * 查找倒数k个元素：两个指针前后扫描
     * 循环链表，双向循环链表
   * 顺序表和链表的比较：
     * 顺序表：优点，随机存取；缺点：插入删除需要移动元素
     * 链表：优点，插入删除不需要移动元素；缺点：不能随机存取

** 栈和队列
   * 栈：插入删除固定在某一端(FILO); 队列：插入一端，删除在另一端(FIFO)
   * 栈原理：栈空top=-1, 进栈top+1, 出栈top-1, 栈空不能pop, 栈满不能push
   * 两栈共享空间：栈底在两头，左边push：top++, 右边push：top--，两边相反
   * 链表实现，表头作为栈顶，头插方便,push没有上限，直至内存耗尽
   * 递归：递归的实现需要用栈,自己调用自己,递归必须有条件限制(求阶乘，汉诺塔)
     *编写递归算法的思路:*
     * 将大问题分解为若干个小问题，并且小问题的与大问题的解决算法一样
     * 寻找递归的终止条件和结果，当小问题小到什么时候，可以知道结果
     *编写求解汉诺塔问题的算法:*
     * 将n-1个盘中搬到B,将最后一个盘子搬到C,将n-1个盘子搬到C，完成
   * 栈的应用：表达式求值
     - 转化为后缀表达式
       * 不需要栈
     - 运算符优先法
       * 两个栈：运算符栈，操作数栈
       * 每当运算符要进栈时，当前运算符与栈顶运算符比较，小于等于pop，大于push
       * 出栈运算结果再进栈
       * pop时，下面的操作数 exp 上面操作数
   * 表达式
     * 前缀，中缀，后缀
     * 后缀：操作数位置不变，调整的是运算符位置
   * /第三章上机实验：输入一个算术表达式，利用算符优先法求值。例：86.35+(78.4-60.5)*1000/
--------------------------
   * 顺序队列:(循环队列)
     * 进队:(rear+1)%MaxSize , 出队:(front+1)%MaxSize
     * front指向头节点前面，rear指向实际的尾节点
     * 队空时front=rear,队空时不能出队，队满时不能进队
     * 如何解决判断队空还是队满的情况？
       * 浪费一个空间，队满时rear=MaxSize-1，即：(rear+1)%MAxsize==front
       * 设置一个布尔变量flag
       * 记录元素个数,num放在class中
   * 链式队列：
     * 出队：删除头节点，出队：插入尾节点
     * 只有一个节点时，出队需要将rear保护起来，让front=rear

** 字符串
   * 串的连接
   * 串的比较
   * 串的复制
   * 倒转一句英文
   * 删除特定字符
   * 模式匹配
     * BF算法:时间复杂性->最好O(n+m),最坏O(n*m)
     * KMP算法:关键是next()数组
       * next数组至于模式串有关
       * next数组算法: j=0时匹配失败,next[j]=-1; 否则 next[j]=前缀字串和后缀字串相等时的最大长度
       * 思想:模式串回溯next[j]的长度
   * 上机实验：串的查找替换，输入3个串s,t,p,将s串中所有的t串替换成p串。

** 数组和特殊矩阵
   * 数组特点：
     * 线性表本质：相同类型的线性序列
     * 存储结构：行优先顺序，列优先顺序
     * 随机存取，地址可计算
   * 特殊矩阵
     * 对称矩阵
     * 三角矩阵
     * 对角矩阵
     * 稀疏矩阵：只存放非零元素，三元组表法，十字链表法

** 广义表
   * 概念：
     * 线性表是特殊的广义表，广义表是非特殊结构，数据类型可以不同
     * 长度，深度，表头，表尾:除表头外剩余部分
** 树与二叉树
*** 概念
    * 顺序存储：利用完全二叉树的性质：左孩子的下表是父节点的二倍(从1开始)
    * 链式存储：一个data，两个指针
    * 遍历顺序:
      * 先序遍历：根左右,根节点第一个访问
      * 中序遍历：左根右
      * 后序遍历：左右根，根节点最后一个访问
      * 层次遍历：一层层遍历,使用队列实现
    * 遍历的序列与二叉树的关系:
      * 一个遍历序列不能确定唯一的二叉树
      * 先序和中序两个序列可以确定唯一的二叉树(中序可以分左右)
      * 后序和中序两个序列也可以确定唯一的二叉树
    * 遍历算法:
      * 先序,中序,后序：递归
      * 层次遍历：队列实现，保存节点的指针

*** 线索二叉树(线索：指向前驱或后继的指针)
    * 原因：一般的二叉树存在n+1个空指针(n为节点数)，把空指针作为指向前驱或者后继的指针。指针有两个功能：指向孩子节点或者前驱后继节点，使用标记flag区分(广义表思想)。flag=0,指向            子节点，flag=1，指向前驱或后继节点。
    * 找后继节点：if flag=1,取线索， if flag=0,有右孩子，且右孩子没有左孩子，则后继为该右孩子；如果右孩子有左孩子，则一直往下找到最终的左孩子。(同理找前驱节点)
    * 遍历:利用求后继节点的算法。第一个节点：从根节点一直往下找最后一个左孩子
    * 找父节点：左孩子身份出现往右走，右孩子身份出现往左走
*** 树
    * 存储结构
      * 多叉链表表示法：选择节点数最多的个数来确定每个节点的指针数。空间利用率低。
      * 孩子链表表示法：
      * 双亲表示法：
      * 孩子兄弟表示法：左指针指向真正的左孩子，右指针指向兄弟节点
    * 求树的高度
    * 树中所有节点的度
    * 遍历：先根(与二叉树的先序遍历一致)，后根(与二叉树中序遍历一致)
*** Huffman树与Huffman编码
    * 概念：
      * 等长编码与不等长编码
      * 编码不能有二义性，一个编码不能是另一个编码的前缀
      * Huffman编码是不等长编码
      * 出现频率高的编码bit少，频率低的编码bit多，压缩优化
      * Huffman树 = 最优二叉树：带权路径长度最小权值 = 编码的最终长度
      * Huffman树没有单独的节点，节点总数为2n-1
      * 算法：把所有的节点都作为根节点，每次都选两个最小的根节点生成新的根节点
      * 实现：用结构体数组

** 图
*** 概念
    * 顶点集和边集
    * 邻节点
    * 无向完全图边数：n(n-1)/2
    * 有向完全图边数：n(n-1)
    * 带权图(网)，无权图
    * 顶点的度：与顶点相连的边的条数
    * 入度，出度
    * 路径，路径长度
    * 简单路径：不形成环
    * 回路：环
    * 连通图：从一个节点可以到达所有节点
    * 连通分量：不连通图中连通的部分
    * 强连通图：有向连通图
    * 强连通分量：有向图的连通分量
    * 生成树：
*** 存储结构
    * 邻接矩阵表示法
      * 无向图：矩阵对称, 每一行的和为该顶点的度数
      * 有向图：每个顶点的出度为1, 每一行的和为入度，每一列的和为出度
      * 网：有边用权值表示，没有边表示为0或无穷大
      * 通过输入实现顶点与边的关系
    * 邻接表表示法
      * 类似树的孩子链表表示法，孩子为图中的邻接点
      * 带权邻接表：在每个节点中增加一个权值域
    * 优缺点：
*** 遍历
    * 深度优先DFS(递归)
      * 按照一定的顺序不断深入，没有邻接点则返回，依次递归
      * 可以判断图是否连通以及求连通分量(算法)
      * 搜索结果为深度优先搜索生成树
    * 广度优先BFS(非递归)
      * 类似树的层次遍历，队列实现
*** 最小生成树
    * Prim算法：任选一个顶点加入集合u,其余加入v-u,选择v与u之间权值最小的边，将对应的顶点加入集合u,以此类推。
      * 实现：引入辅助数组minidege[i]表示顶点i到u集合的最小边，每加一个顶点要更新
    * Kruskal算法：每次选最小的边，构成回路则舍弃
    * 最短路径算法：Dijkstra(?理解)
      * S={v}, 集合V-S中存放各顶点间的初始距离值
      * 循环n-1次，选取距离最小的点，加入集合S
      * 加入集合S的点用1表示，未加入的用0表示
      * path[]数组存放从源点到点vi的距离
    * Floyd算法(所有顶点间的最短路径)（自学！）
*** 拓扑排序(有向无环图:AOV网)
    * 结果：顶点序列
    * 含义：工程完成有先决条件和先后次序
    * 拓扑排序算法可以判断有向图是否有环
    * 参与排序的顶点入度为0
    * 算法
      * 选取入度为0的顶点，并且删除其发出的边
      * 每次输出入度为0的顶点
      * 若全部输出n各顶点，则完成
      * 如输出的顶点树小于n，则有环，拓扑排序失败
    * 关键实现
      * 入度为0顶点的存放：堆栈，队列或其他
      * 出边的删除=>入度减1
      * 采用邻接表存储
** 查找
*** 概念
    * 根据数据的组织方式确定查找算法
    * 一般数据：顺序查找
    * 排序：二分查找
    * 索引表：索引查找
    * 二叉排序树：二叉排序树查找
    * Hash表：Hash查找
    * 平均查找长度的计算
*** 顺序查找
    * 无监视哨
    * 有监视哨：不需要判断i<n
    * 平均查找长度：(n+1)/2
*** 二分查找
    * low > high查找失败
    * 非递归
    * 递归
    * 二分查找树
    * 时间复杂性：O(log2^n)
*** 分块查找
    * 特点
      * 又叫索引查找
      * 对顺序查找的一种改进，性能介于顺序查找与二分查找之间
      * 部分有序
      * 建立索引表
    * 思想
      * 先找k所在的块
      * 在块内进行查找
    * 平均查找长度计算
      *
*** 树表查找
    * 二叉排序树：左子树所有节点小于根节点，右子树所有节点大于根节点
    * 中序遍历为有序序列，可判断是否为二叉排序树(算法实现)
    * 建立二叉排序树:第一个元素作为根节点，每次插入作为叶子节点找位置
    * 存储结构：与二叉树的存储结构一样
    * 插入操作：
      * 用递归实现
      * 引用传递(传递的是地址，可以双向传递)
      * 小的插在左边，大的插右边
    * 查找操作：与二分查找判定树一致
      * 平均查找长度
	* 成功时：查找次数和/节点个数
	* 失败时：..../(节点个数+1)
      * 时间复杂度
	* 树高最大：n
	* 树高最小：log2^n
	* 最好：O(log2^n)
	* 最差：O(n)
    * 删除操作：分三种情况,最复杂的情况运用了线索二叉树的思想
    * 平衡二叉树
      * 概念
	* 平衡二叉树：根节点的左右子树深度最多相差1，根节点的左子树和右子树也是平衡二叉树
	* 平衡因子：节点的左子树的深度和左子树深度的差
      * 构造
	* 插入一个节点时，计算节点的平衡因子
	* 若不平衡，则进行旋转操作
      * /平衡因子的计算/
	* 利用求树的高度算法改造
    * B树
    * B+树
      * 最后一层是关键字
      * 上面的层起索引作用
	
*** Hash查找
**** 概念
     * hash表：通过hash函数计算得到关键字位置以及解决冲突后所建立的表
     * hash函数：构建hash表的方法
     * hash冲突：两人关键字不同，但是计算出的hash值相同
     * 同义词：hash值相等的两个关键字
     * hash查找：基于hash表的查找
**** 常用的hash函数
     * 直接定值法
     * 除留余数法：H(k) = key%p(p为质数)
     * 数学分析法：根据数字特征
     * 平方取中法
     * 折叠法
**** hash冲突解决方法
     * 开发定址法
       * 线性探测法：遇到冲突，偏移量增加
       * 二次探测法：遇到冲突，偏移量来回加减平方值
       * 随机探测法
     * 链地址法
       * 相同位置的关键字用链表挂在位置上
**** 平均查找长度
     * 成功：(不冲突+冲突)/关键字数
     * 不成功：每个位置到空位置的长度和/表长度
**** 算法
      * hash表建立算法
      * hash查找算法
*** 实验
    * 输入一组数据，建立一颗二叉排序树，并检验是否为二叉排序树.
